import crypto from "node:crypto";
import fs from "node:fs";
import path from "node:path";

function readArg(flag) {
  const idx = process.argv.indexOf(flag);
  if (idx === -1) return null;
  const value = process.argv[idx + 1];
  if (!value || value.startsWith("--")) return null;
  return value;
}

function* walkHtmlFiles(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) yield* walkHtmlFiles(fullPath);
    else if (entry.isFile() && fullPath.endsWith(".html")) yield fullPath;
  }
}

function computeInlineScriptHashes(html) {
  const hashes = new Set();
  // Match inline scripts defensively (CodeQL: js/bad-tag-filter).
  // Tolerate malformed closing tags like `</script >` or even `</script\t\n foo>`.
  const scriptRe = /<script\b([^>]*)>([\s\S]*?)<\/script\b[^>]*>/gi;

  let match;
  while ((match = scriptRe.exec(html))) {
    const attrs = match[1] ?? "";
    const body = match[2] ?? "";

    // External scripts are covered by `'self'` and don't need hashes.
    if (/\bsrc\s*=/i.test(attrs)) continue;

    // Ignore JSON-LD blocks.
    const type = (attrs.match(/\btype\s*=\s*"([^"]+)"/i)?.[1] ?? "").toLowerCase();
    if (type === "application/ld+json") continue;

    // Ignore empty scripts.
    if (!body.trim()) continue;

    const digest = crypto.createHash("sha256").update(body, "utf8").digest("base64");
    hashes.add(digest);
  }

  return hashes;
}

const outDir = path.resolve(readArg("--out-dir") ?? "out");
const target = path.resolve(
  readArg("--target") ?? "infrastructure/lib/generated/next-inline-script-hashes.ts",
);
const perPathTarget = path.resolve(
  readArg("--per-path-target") ?? "infrastructure/lib/generated/next-inline-script-hashes.json",
);
const perPathJsTarget = path.resolve(
  readArg("--per-path-js-target") ?? "infrastructure/lib/generated/next-inline-script-hashes.js",
);
const kvsTarget = path.resolve(
  readArg("--kvs-target") ?? "infrastructure/lib/generated/next-inline-script-hashes.kvs.json",
);
const functionTarget = path.resolve(
  readArg("--function-target") ??
    "infrastructure/lib/functions/cloudfront/next-csp-response.js",
);

if (!fs.existsSync(outDir)) {
  console.error(`out dir not found: ${outDir}`);
  console.error("Run `pnpm build` first so the static export exists.");
  process.exit(1);
}

const allHashes = new Set();
const perPathHashes = {};
const htmlFiles = [...walkHtmlFiles(outDir)].sort();
for (const htmlFile of htmlFiles) {
  const html = fs.readFileSync(htmlFile, "utf8");
  const hashes = [...computeInlineScriptHashes(html)].sort();
  for (const hash of hashes) allHashes.add(hash);
  const relativePath = `/${path
    .relative(outDir, htmlFile)
    .split(path.sep)
    .join("/")}`;
  perPathHashes[relativePath] = hashes;
}

const hashes = [...allHashes].sort();
if (hashes.length === 0) {
  console.error("No inline script hashes found. Is this a Next.js static export?");
  process.exit(1);
}

fs.mkdirSync(path.dirname(target), { recursive: true });
fs.writeFileSync(
  target,
  `/**
 * Generated file -- do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * This contains a SHA-256 allow-list of inline \`<script>\` blocks emitted by the
 * Next.js static export (App Router). CloudFront uses these hashes in CSP
 * \`script-src\` to keep a strict policy without \`unsafe-inline\`.
 */
export const NEXT_INLINE_SCRIPT_HASHES = [
${hashes.map((hash) => `  "sha256-${hash}",`).join("\n")}
] as const;
`,
  "utf8",
);

const perPathHashesSha = Object.fromEntries(
  Object.entries(perPathHashes).map(([key, value]) => [
    key,
    value.map((hash) => `sha256-${hash}`),
  ]),
);

fs.mkdirSync(path.dirname(perPathTarget), { recursive: true });
fs.writeFileSync(perPathTarget, `${JSON.stringify(perPathHashesSha, null, 2)}\n`, "utf8");

const hashIndexByDigest = new Map(hashes.map((hash, idx) => [hash, idx]));
const perPathHashIndexes = Object.fromEntries(
  Object.entries(perPathHashes).map(([key, value]) => {
    const indices = value
      .map((hash) => {
        const idx = hashIndexByDigest.get(hash);
        if (idx === undefined) {
          throw new Error(`Missing global hash index for digest on ${key}: ${hash}`);
        }
        return idx;
      })
      .sort((a, b) => a - b);
    const encoded = indices.map((i) => i.toString(36)).join(".");
    return [key, encoded];
  }),
);

const kvsData = Object.entries(perPathHashIndexes).map(([key, value]) => ({ key, value }));
for (const { key, value } of kvsData) {
  const keyBytes = Buffer.byteLength(key, "utf8");
  const valueBytes = Buffer.byteLength(value, "utf8");
  if (keyBytes > 512) {
    console.error(
      `CloudFront KeyValueStore key exceeds 512 bytes: ${keyBytes} bytes (${key})`,
    );
    process.exit(1);
  }
  if (valueBytes > 1024) {
    console.error(
      `CloudFront KeyValueStore value exceeds 1,024 bytes: ${valueBytes} bytes (${key})`,
    );
    process.exit(1);
  }
}

fs.mkdirSync(path.dirname(kvsTarget), { recursive: true });
const kvsPayload = JSON.stringify({ data: kvsData }, null, 2) + "\n";
const kvsPayloadBytes = Buffer.byteLength(kvsPayload, "utf8");
const keyValueStoreLimitBytes = 5 * 1024 * 1024;
if (kvsPayloadBytes > keyValueStoreLimitBytes) {
  console.error(
    `CloudFront KeyValueStore import payload exceeds the 5 MB limit: ${kvsPayloadBytes} bytes > ${keyValueStoreLimitBytes} bytes (${kvsTarget})`,
  );
  process.exit(1);
}
fs.writeFileSync(kvsTarget, kvsPayload, "utf8");

const perPathFunctionSource = `/* biome-ignore format: Keep output compact (CloudFront Function size limits). */
/* biome-ignore-all lint/style/useTemplate: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/correctness/noUnusedVariables: CloudFront Functions require globals. */
/* biome-ignore-all lint/style/useConst: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/suspicious/noGlobalIsNan: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/correctness/noInnerDeclarations: CloudFront Functions require ES5.1. */
/**
 * Generated file -- do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * CloudFront Functions runtime constraints:
 * - JavaScript runtime 2.0
 * - Data lives in CloudFront KeyValueStore (KVS)
 */
var HASH_B64 = ${JSON.stringify(hashes)};
var PATH_HASH_INDEXES = ${JSON.stringify(perPathHashIndexes)};
`;

fs.mkdirSync(path.dirname(perPathJsTarget), { recursive: true });
fs.writeFileSync(perPathJsTarget, `${perPathFunctionSource}\n`, "utf8");

const functionSource = `/* biome-ignore format: Keep output compact (CloudFront Function 10 KB limit). */
/* biome-ignore-all assist/source/organizeImports: Generated file with compact output. */
/* biome-ignore-all lint/style/useTemplate: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/complexity/useOptionalChain: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/correctness/noUnusedVariables: CloudFront handler is invoked by AWS. */
/* biome-ignore-all lint/style/useConst: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/suspicious/noGlobalIsNan: CloudFront Functions require ES5.1. */
/* biome-ignore-all lint/correctness/noInnerDeclarations: CloudFront Functions require ES5.1. */
/**
 * Generated file -- do not edit by hand.
 *
 * Generated by: \`pnpm generate:csp-hashes\`
 *
 * CloudFront Functions runtime constraints:
 * - JavaScript runtime 2.0
 * - Uses CloudFront KeyValueStore for per-path hash indices (keeps code size < 10 KB)
 */
import cf from "cloudfront";
var kvsHandle = cf.kvs();

var HASH_B64 = ${JSON.stringify(hashes)};

var BASE_DIRECTIVES = [
  "default-src 'self'",
  "img-src 'self' data: blob:",
  "style-src 'self' 'unsafe-inline'",
  "font-src 'self' data:",
  "frame-ancestors 'none'",
  "base-uri 'self'",
  "form-action 'self'",
  "upgrade-insecure-requests"
];

var SCRIPT_PREFIX = "script-src 'self'";

// Include test domains so infra tests can validate connect-src values.
var CONNECT_SRC_BY_HOST = {
  "bjornmelin.io": "https://api.bjornmelin.io",
  "www.bjornmelin.io": "https://api.bjornmelin.io",
  "example.com": "https://api.example.com",
  "www.example.com": "https://api.example.com"
};

function normalizePath(uri) {
  if (!uri) return "/index.html";
  var raw = uri.split("?")[0].split("#")[0];
  var decoded;
  try {
    decoded = decodeURIComponent(raw);
  } catch (error) {
    decoded = raw;
  }
  if (decoded.charAt(decoded.length - 1) === "/") return decoded + "index.html";
  var lastSegment = decoded.split("/").pop() || "";
  if (lastSegment.indexOf(".") === -1) return decoded + "/index.html";
  return decoded;
}

function isHtmlRequest(request, response) {
  var uri = (request && request.uri) || "";
  if (!uri) return false;

  // Skip Next.js internal assets.
  if (uri.indexOf("/_next/") === 0) return false;

  // Prefer content-type when available (viewer-response).
  var contentType =
    response &&
    response.headers &&
    response.headers["content-type"] &&
    response.headers["content-type"].value;
  if (contentType && contentType.indexOf("text/html") === -1) return false;

  var pathOnly = uri.split("?")[0].split("#")[0];
  var last = pathOnly.split("/").pop() || "";
  if (last.indexOf(".") !== -1 && pathOnly.slice(-5) !== ".html") return false;
  return true;
}

function decodeHashList(encoded) {
  if (!encoded) return [];
  var parts = encoded.split(".");
  var out = [];
  for (var i = 0; i < parts.length; i++) {
    var idx = parseInt(parts[i], 36);
    if (isNaN(idx)) continue;
    var digest = HASH_B64[idx];
    if (!digest) continue;
    out.push(digest);
  }
  return out;
}

function buildCsp(host, hashes) {
  var normalizedHost = (host || "").toLowerCase().split(":")[0];
  var connectSrc = CONNECT_SRC_BY_HOST[normalizedHost];
  var scriptParts = [];
  for (var i = 0; i < hashes.length; i++) {
    scriptParts.push("'sha256-" + hashes[i] + "'");
  }
  var script = SCRIPT_PREFIX + (scriptParts.length ? " " + scriptParts.join(" ") : "");
  var connectDirective = connectSrc
    ? "connect-src 'self' " + connectSrc
    : "connect-src 'self'";
  return BASE_DIRECTIVES.concat([script, connectDirective]).join("; ");
}

// lgtm [js/unused-local-variable]
async function handler(event) {
  var request = event.request || {};
  var response = event.response || {};
  if (!isHtmlRequest(request, response)) return response;
  var uri = request.uri || "/index.html";
  var normalized = normalizePath(uri);
  var encoded;
  try {
    encoded = await kvsHandle.get(normalized);
  } catch (error) {
    encoded = null;
  }
  if (encoded == null) {
    try {
      encoded = await kvsHandle.get("/404.html");
    } catch (error) {
      encoded = null;
    }
  }
  if (encoded == null) {
    try {
      encoded = await kvsHandle.get("/index.html");
    } catch (error) {
      encoded = null;
    }
  }
  // Fail-soft: if KVS is unavailable/unpopulated, don't apply CSP yet.
  // The deploy pipeline syncs KVS immediately after the storage stack deploy.
  if (encoded == null) return response;
  var hashes = decodeHashList(encoded);
  var hostHeader =
    request.headers && request.headers.host && request.headers.host.value;
  var csp = buildCsp(hostHeader || "", hashes);
  response.headers = response.headers || {};
  response.headers["content-security-policy"] = { value: csp };
  return response;
}
`;

const functionOutput = `${functionSource}\n`;
const functionOutputBytes = Buffer.byteLength(functionOutput, "utf8");
const cloudFrontFunctionLimitBytes = 10240;
if (functionOutputBytes > cloudFrontFunctionLimitBytes) {
  console.error(
    `Generated CloudFront Function source exceeds the 10,240-byte limit: ${functionOutputBytes} bytes > ${cloudFrontFunctionLimitBytes} bytes (${functionTarget})`,
  );
  process.exit(1);
}

fs.mkdirSync(path.dirname(functionTarget), { recursive: true });
fs.writeFileSync(functionTarget, functionOutput, "utf8");

	process.stdout.write(
	  JSON.stringify(
	    {
	      outDir,
	      target,
	      perPathTarget,
	      perPathJsTarget,
	      kvsTarget,
	      functionTarget,
	      hashCount: hashes.length,
	    },
	    null,
	    2,
	  ) + "\n",
	);
